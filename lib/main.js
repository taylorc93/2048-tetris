// Generated by CoffeeScript 1.7.1

/*
	Coffeescript file that controls game logic and canvas rendering
	Written by Connor Taylor
 */


/*										Constants */

(function() {
  var BOARD_HEIGHT, BOARD_WIDTH, Board, CanvasRenderer, MAX_COLS, MAX_ROWS, TILE_SIZE, Tile, bindKeys, board, gameLoop,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BOARD_WIDTH = 1200;

  BOARD_HEIGHT = 800;

  TILE_SIZE = 50;

  MAX_ROWS = BOARD_HEIGHT / TILE_SIZE;

  MAX_COLS = BOARD_WIDTH / TILE_SIZE;


  /*										Classes */

  CanvasRenderer = (function() {
    function CanvasRenderer(canvas) {
      this.canvas = canvas;
      this.renderTile = __bind(this.renderTile, this);
      this.ctx = this.canvas.getContext('2d');
    }

    CanvasRenderer.prototype.renderTile = function(tile) {
      this.ctx.fillStyle = tile.color;
      return this.ctx.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
    };

    CanvasRenderer.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);
    };

    return CanvasRenderer;

  })();

  Tile = (function() {
    function Tile(x, y) {
      this.x = x;
      this.y = y;
      this.color = "rgb(255,165,0)";
    }

    return Tile;

  })();

  Board = (function() {
    function Board() {
      var x, y;
      this.tiles = [];
      this.renderer = new CanvasRenderer(document.getElementById('gameBoard'));
      x = Math.floor(Math.random() * MAX_COLS) * TILE_SIZE;
      y = (MAX_ROWS - 1) * TILE_SIZE;
      this.tiles.push(new Tile(x, y));
    }

    Board.prototype.render = function() {
      var tile, _i, _len, _ref, _results;
      this.renderer.clear();
      _ref = this.tiles;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        _results.push(this.renderer.renderTile(tile));
      }
      return _results;
    };

    Board.prototype.moveLeft = function() {
      var tile, _i, _len, _ref;
      _ref = this.tiles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        if (tile.x > 0) {
          tile.x -= TILE_SIZE;
        }
      }
      return this.render();
    };

    Board.prototype.moveRight = function() {
      var tile, _i, _len, _ref;
      _ref = this.tiles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        if (tile.x < (BOARD_WIDTH - TILE_SIZE)) {
          tile.x += TILE_SIZE;
        }
      }
      return this.render();
    };

    Board.prototype.spacePressed = function() {
      return console.log('pressed spacebar');
    };

    return Board;

  })();


  /* 							DOM rendering and events */

  board = new Board;

  bindKeys = function() {
    return $(document).bind('keydown', function(e) {
      switch (e.which) {
        case 32:
          return board.spacePressed();
        case 37:
          return board.moveLeft();
        case 39:
          return board.moveRight();
        case 40:
          return board.moveDown();
      }
    });
  };

  gameLoop = function() {
    console.log("next iter");
    return board.render();
  };

  $(function() {
    board.render();
    return bindKeys();
  });

}).call(this);
