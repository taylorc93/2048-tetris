// Generated by CoffeeScript 1.7.1

/*
	Coffeescript file that controls game logic and canvas rendering
	Written by Connor Taylor
 */


/*										Constants */

(function() {
  var BOARD_HEIGHT, BOARD_WIDTH, Board, COLORS, CanvasRenderer, MAX_COLOR_INDEX, MAX_COLS, MAX_ROWS, MAX_X, MAX_Y, TILE_SIZE, Tile, bindKeys, board, gameLoop;

  COLORS = ["#FFFF00", "#FF9900", "#FF0000", "#9900FF", "#0000FF", "#00FF00", "#000000"];

  MAX_COLOR_INDEX = 6;

  BOARD_WIDTH = 1200;

  BOARD_HEIGHT = 800;

  TILE_SIZE = 50;

  MAX_ROWS = BOARD_HEIGHT / TILE_SIZE;

  MAX_COLS = BOARD_WIDTH / TILE_SIZE;

  MAX_X = BOARD_WIDTH - TILE_SIZE;

  MAX_Y = BOARD_HEIGHT - TILE_SIZE;


  /*										Classes */

  CanvasRenderer = (function() {
    function CanvasRenderer(canvas) {
      this.canvas = canvas;
      this.ctx = this.canvas.getContext('2d');
    }

    CanvasRenderer.prototype.renderTile = function(tile) {
      this.ctx.fillStyle = COLORS[tile.colorIndex];
      return this.ctx.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
    };

    CanvasRenderer.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);
    };

    return CanvasRenderer;

  })();

  Tile = (function() {
    function Tile(x, y) {
      this.x = x;
      this.y = y;
      this.colorIndex = 0;
      this.hasMoved = false;
    }

    return Tile;

  })();

  Board = (function() {
    function Board() {
      var col, row, x, y;
      this.tiles = (function() {
        var _i, _results;
        _results = [];
        for (x = _i = 0; 0 <= MAX_ROWS ? _i < MAX_ROWS : _i > MAX_ROWS; x = 0 <= MAX_ROWS ? ++_i : --_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (y = _j = 0; 0 <= MAX_COLS ? _j < MAX_COLS : _j > MAX_COLS; y = 0 <= MAX_COLS ? ++_j : --_j) {
              _results1.push(null);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      this.renderer = new CanvasRenderer(document.getElementById('gameBoard'));
      row = MAX_ROWS - 1;
      col = Math.floor(Math.random() * MAX_COLS);
      x = col * TILE_SIZE;
      y = row * TILE_SIZE;
      this.tiles[row][col] = new Tile(x, y);
    }

    Board.prototype.render = function() {
      var count, x, y, _i, _results;
      this.renderer.clear();
      count = 0;
      _results = [];
      for (x = _i = 0; 0 <= MAX_ROWS ? _i < MAX_ROWS : _i > MAX_ROWS; x = 0 <= MAX_ROWS ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= MAX_COLS ? _j < MAX_COLS : _j > MAX_COLS; y = 0 <= MAX_COLS ? ++_j : --_j) {
            if (this.tiles[x][y] !== null) {
              _results1.push(this.renderer.renderTile(this.tiles[x][y]));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.spawnTile = function() {
      var col, row, tile, x, y;
      row = 0;
      col = Math.floor(Math.random() * MAX_COLS);
      x = col * TILE_SIZE;
      y = 0;
      tile = new Tile(x, y);
      return this.tiles[row][col] = tile;
    };

    Board.prototype.updatePositions = function() {
      var col, row, tile, _i, _j, _k, _results;
      for (row = _i = 0; 0 <= MAX_ROWS ? _i < MAX_ROWS : _i > MAX_ROWS; row = 0 <= MAX_ROWS ? ++_i : --_i) {
        for (col = _j = 0; 0 <= MAX_COLS ? _j < MAX_COLS : _j > MAX_COLS; col = 0 <= MAX_COLS ? ++_j : --_j) {
          tile = this.tiles[row][col];
          if (tile !== null && tile.y !== MAX_Y && !tile.hasMoved) {
            if (this.tiles[row + 1][col] === null) {
              this.tiles[row][col] = null;
              tile.y += TILE_SIZE;
              tile.hasMoved = true;
              this.tiles[row + 1][col] = tile;
            }
          }
        }
      }
      _results = [];
      for (row = _k = 0; 0 <= MAX_ROWS ? _k < MAX_ROWS : _k > MAX_ROWS; row = 0 <= MAX_ROWS ? ++_k : --_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (col = _l = 0; 0 <= MAX_COLS ? _l < MAX_COLS : _l > MAX_COLS; col = 0 <= MAX_COLS ? ++_l : --_l) {
            if (this.tiles[row][col] !== null) {
              _results1.push(this.tiles[row][col].hasMoved = false);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.moveLeft = function() {
      var col, leftTile, row, tile, _i, _j;
      for (row = _i = 0; 0 <= MAX_ROWS ? _i < MAX_ROWS : _i > MAX_ROWS; row = 0 <= MAX_ROWS ? ++_i : --_i) {
        for (col = _j = 0; 0 <= MAX_COLS ? _j < MAX_COLS : _j > MAX_COLS; col = 0 <= MAX_COLS ? ++_j : --_j) {
          tile = this.tiles[row][col];
          leftTile = this.tiles[row][col - 1];
          if (tile !== null && tile.x !== 0 && !tile.hasMoved) {
            if (leftTile === null) {
              tile.x -= 50;
              tile.hasMoved = true;
              this.tiles[row][col - 1] = tile;
              this.tiles[row][col] = null;
            } else if (leftTile !== null && leftTile.colorIndex === tile.colorIndex) {
              this.tiles[row][col - 1].colorIndex++;
              this.tiles[row][col - 1].hasMoved = true;
              this.tiles[row][col] = null;
            } else {
              continue;
            }
          }
        }
      }
      return this.render();
    };

    Board.prototype.moveRight = function() {
      var col, rightTile, row, tile, _i, _j;
      for (row = _i = 0; 0 <= MAX_ROWS ? _i < MAX_ROWS : _i > MAX_ROWS; row = 0 <= MAX_ROWS ? ++_i : --_i) {
        for (col = _j = 0; 0 <= MAX_COLS ? _j < MAX_COLS : _j > MAX_COLS; col = 0 <= MAX_COLS ? ++_j : --_j) {
          tile = this.tiles[row][col];
          rightTile = this.tiles[row][col + 1];
          if (tile !== null && tile.x !== MAX_X && !tile.hasMoved) {
            if (rightTile === null) {
              tile.x += 50;
              tile.hasMoved = true;
              this.tiles[row][col + 1] = tile;
              this.tiles[row][col] = null;
            } else if (rightTile !== null && rightTile.colorIndex === tile.colorIndex) {
              this.tiles[row][col + 1].colorIndex++;
              this.tiles[row][col + 1].hasMoved = true;
              this.tiles[row][col] = null;
            } else {
              continue;
            }
          }
        }
      }
      return this.render();
    };

    Board.prototype.moveDown = function() {
      var bottomTile, col, row, tile, _i, _results;
      _results = [];
      for (row = _i = 0; 0 <= MAX_ROWS ? _i < MAX_ROWS : _i > MAX_ROWS; row = 0 <= MAX_ROWS ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (col = _j = 0; 0 <= MAX_COLS ? _j < MAX_COLS : _j > MAX_COLS; col = 0 <= MAX_COLS ? ++_j : --_j) {
            tile = this.tiles[row][col];
            bottomTile = this.tiles[row + 1][col];
            if (tile !== null && tile.y !== MAX_Y && !tile.hasMoved) {
              if (bottomTile === null) {
                tile.y += 50;
                tile.hasMoved = true;
                this.tiles[row + 1][col] = tile;
                _results1.push(this.tiles[row][col] = null);
              } else if (bottomTile !== null && bottomTile.colorIndex === tile.colorIndex) {
                this.tiles[row + 1][col].colorIndex++;
                this.tiles[row + 1][col].hasMoved = true;
                _results1.push(this.tiles[row][col] = null);
              } else {
                continue;
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.spacePressed = function() {
      return console.log('pressed spacebar');
    };

    return Board;

  })();


  /* 									Events and logic */

  board = new Board;

  bindKeys = function() {
    return $(document).bind('keydown', function(e) {
      switch (e.which) {
        case 32:
          return board.spacePressed();
        case 37:
          return board.moveLeft();
        case 39:
          return board.moveRight();
        case 40:
          return board.moveDown();
      }
    });
  };

  gameLoop = function() {
    board.updatePositions();
    board.spawnTile();
    return board.render();
  };

  $(function() {
    board.render();
    bindKeys();
    return setInterval(gameLoop, 250);
  });

}).call(this);
